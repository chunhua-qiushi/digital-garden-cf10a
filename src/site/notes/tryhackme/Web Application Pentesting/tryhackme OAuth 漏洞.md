---
{"dg-publish":true,"permalink":"/tryhackme/Web Application Pentesting/tryhackme OAuth 漏洞/","tags":["tryhackme","web安全"]}
---

## 目标
在整个房间里，将全面了解以下关键概念：

    OAuth 2.0 的基本概念（授权类型）
    OAuth 2.0 flow  OAuth 2.0 流程
    Identify OAuth services  标识 OAuth 服务
    Exploitation techniques  开发技术
    Evolution of OAuth 2.1  OAuth 2.1 的演变


## task 2 关键概念
### 资源所有者
资源所有者是控制某些数据并可以授权应用程序代表他们访问该数据的人员或系统。
### 客户端
客户端可以是移动应用程序或服务器端 Web 应用程序，它充当中介，请求访问资源并在资源所有者允许的情况下执行操作
### 授权服务器
授权服务器负责在成功验证资源所有者并获得其授权后向客户端颁发访问令牌。
### 资源服务器
托管受保护资源的服务器可以使用访问令牌接受和响应受保护资源请求。
### Authorization Grant  授权授予
客户端使用表示资源所有者授权的凭据（访问其受保护的资源）来获取访问令牌。主要授权类型是 Authorization Code, Implicit, Resource Owner Password Credentials, and Client Credentials
### Access Token  访问令牌
客户端可用于代表资源所有者访问受保护资源的凭据。它的寿命和范围有限。访问令牌对于维护客户端和资源服务器之间安全和受保护的通信至关重要，而无需反复要求资源所有者提供凭据。
### Refresh Token  刷新令牌
客户端可用于获取新访问令牌的凭据，而无需资源所有者重新进行身份验证。刷新令牌通常寿命很长，并提供了一种维护用户会话的方法，而不会频繁中断登录。例如，当访问令牌过期时，Web 应用将使用刷新令牌获取新的访问令牌，因此无需再次登录。
### Redirect URI  重定向 URI
授权服务器在授予或拒绝授权后将资源所有者的用户代理重定向到的 URI。它检查请求授权响应的客户端是否正确。
### Scope  作用域
作用域是一种限制应用程序对用户帐户的访问的机制。它们允许客户端指定所需的访问级别，并允许授权服务器通知用户应用程序请求的访问级别。
### State Parameter  状态参数
可选参数维护客户端和授权服务器之间的状态。它可以通过确保响应与客户端的请求匹配来帮助防止 CSRF 攻击。状态参数是保护 OAuth 流的关键部分。
### Token & Authorization Endpoint  令牌和授权端点
授权服务器的端点是客户端将授权授予（或刷新令牌）交换为访问令牌的地方。相比之下，授权端点是对资源所有者进行身份验证并授权客户端访问受保护资源的地方。

![image.png](https://s2.loli.net/2025/09/15/FSQ9DOdBTUuGECq.png)
## task 3 授权类型
### Authorization Code Grant  授权码授予
授权码授权是最常用的 OAuth 2.0 流，适用于服务器端应用程序（PHP、JAVA、.NET 等）。在此流中， **客户端将用户重定向到授权服务器，用户在其中进行身份验证并授予授权** 。然后，授权服务器使用**授权代码**将用户重定向到客户端。客户端通过请求授权服务器的令牌端点来交换访问令牌的授权代码。
![image.png](https://s2.loli.net/2025/09/15/RnLfdg4HjtS3ks1.png)


### Implicit Grant  隐式授权
隐式授权主要设计用于客户端无法安全存储机密的移动和 Web 应用程序。它**直接向客户端颁发访问令牌，无需交换授权码** 。在此流中，客户端将用户重定向到授权服务器。用户进行身份验证并授予授权后，授权服务器会在 **URL 片段中返回访问令牌**

![image.png](https://s2.loli.net/2025/09/15/azxPq9IYR5GpXFb.png)

### Resource Owner Password Credentials Grant  资源所有者密码凭据授予
当客户端受到资源所有者（例如第一方应用程序） **的高度信任**时，将使用资源所有者密码凭据授予。客户端直接收集用户的凭据（用户名和密码）并将其交换为访问令牌，如下所示：
![image.png](https://s2.loli.net/2025/09/15/aedREGTwUIyM4Ks.png)
在此流中，用户直接向客户端提供其凭据。然后，客户端将凭据发送到授权服务器，授权服务器验证凭据并颁发访问令牌。这种授权类型是直接的，需要较少的交互，使其适用于用户有信心提供凭据的高度可信的应用程序。但是，它的安全性较低，因为它涉及直接与客户端共享凭据，并且不适合第三方应用程序。
### Client Credentials Grant  客户端凭据授予
客户端凭据授权用于无需用户参与的服务器到服务器交互。客户端使用其凭据向授权服务器进行身份验证并获取访问令牌。在此流程中，客户端使用其客户端凭据（客户端 ID 和密钥）向授权服务器进行身份验证，授权服务器直接向客户端颁发访问令牌，如下所示：
![image.png](https://s2.loli.net/2025/09/15/SwdVnOiDRJHkaEt.png)
这种授权类型适用于后端服务和服务器到服务器通信，因为它不涉及用户凭据，从而降低了与用户数据泄露相关的安全风险。
![image.png](https://s2.loli.net/2025/09/15/pwuFy8NSkVsYTUJ.png)

## task 4 How OAuth Flow Works  OAuth 流的工作原理
当用户（资源所有者）与客户端应用程序（客户端）交互并请求访问特定资源时，OAuth 2.0 流开始。客户端将用户重定向到授权服务器，在授权服务器中提示用户登录并授予访问权限。如果用户同意，授权服务器将颁发授权码，客户端可以将其兑换为访问令牌。此访问令牌允许客户端访问资源服务器并代表用户检索请求的资源。
![image.png](https://s2.loli.net/2025/09/15/AuVLc9NOoYGefMC.png)
这里需要开始做题了
是一个登录界面和一串密码
- **Victim**: `victim:victim123`  
    **受害者** ： `受害者：受害者 123`
- **Attacker**: `attacker:tesla@123`  
    **攻击者** ： `攻击者：tesla@123`

一个登录界面，点击 login with bistro
![image.png](https://s2.loli.net/2025/09/15/iMoBjqzPXAbNsh1.png)

会出现以下界面，会有一大串的 url
![image.png](https://s2.loli.net/2025/09/15/MIH8rAjSq9bOX3t.png)

```
http://coffee.thm:8000/accounts/login/?next=/o/authorize/%3Fclient_id%3Dzlurq9lseKqvHabNqOc2DkjChC000QJPQ0JvNoBt%26response_type%3Dcode%26redirect_uri%3Dhttp%3A//bistro.thm%3A8000/oauthdemo/callback
```
- `response_type=code`：这表示 `CoffeeShopApp` 需要授权码作为回报。
-  `state`：一个 CSRF 令牌，用于确保请求和响应是同一事务的一部分。
-  `client_id`：客户端应用程序的公共标识符，唯一标识 `CoffeeShopApp`。
-  `redirect_uri`：授权服务器在 Tom 授予权限后将发送给 Tom 的 URL。这必须与客户端应用程序的预注册重定向 URI 之一匹配。
-  `范围` ：指定请求的访问级别，例如查看咖啡订单。

### Token Response  令牌响应
授权服务器的响应包括以下内容：

-  `access_token`：将用于访问 Tom 详细信息的令牌。
-  `token_type`：通常是“承载者”。
- `expires_in`：访问令牌有效的持续时间（以秒为单位）。
-  `refresh_token（可选）：` 用于获取新访问令牌的令牌，而无需用户再次登录。


## tasks 5 Identifying the OAuth Services  识别 OAuth 服务
在分析登录过程中的网络流量时，请注意 HTTP 重定向。OAuth 实现通常会将浏览器重定向到授权服务器的 URL。此 URL 通常包含特定的查询参数，例如 `response_type` 、 、 `client_id` `redirect_uri` `scope` 、 `state` 和 。这些参数表示正在进行的 OAuth 流。例如，URL 可能如下所示：  

```
https://dev.coffee.thm/authorize?response_type=code&client_id=AppClientID&redirect_uri=https://dev.coffee.thm/callback&scope=profile&state=xyzSecure123
```

识别 OAuth 框架

确认正在使用 OAuth 后，下一步就是确定应用程序采用的特定框架或库。这可以提供对潜在漏洞的洞察和适当的安全评估。以下是识别 OAuth 框架的一些策略：
 
 - **HTTP 标头和响应** ：检查 HTTP 标头和响应正文中是否有引用特定 OAuth 库或框架的唯一标识符或注释。
    **源代码分析** ：如果可以访问应用程序的源代码，请搜索可以显示正在使用的框架的特定关键字和导入语句。例如，`Node.js` 中的 `django-oauth-toolkit`、`oauthlib`、`spring-security-oauth` 或 `passport` 等库，每个库都有独特的特征和命名约定。
- **授权和令牌端点** ：分析用于获取授权码和访问令牌的端点。不同的 OAuth 实现可能具有独特的端点模式或结构。例如， `Django OAuth 工具包` 通常遵循 `/oauth/authorize/` 和 `/oauth/token/` 模式，而其他框架可能使用不同的路径。
- **错误消息** ：自定义错误消息和调试输出可能会无意中泄露底层技术堆栈。详细的错误消息可能包括对特定 OAuth 库或框架的引用。


## task 6 Exploiting OAuth - Stealing OAuth Token  利用 OAuth - 窃取 OAuth 令牌
令牌在 OAuth 2.0 框架中发挥着关键作用，充当授予对受保护资源的访问权限的数字密钥。这些令牌由授权服务器颁发，并根据 `redirect_uri` 参数重定向到客户端应用程序。这种重定向在 OAuth 流程中至关重要，可确保令牌安全地传输到预期接收者。但是，如果 `redirect_uri` 没有得到很好的保护，攻击者可以利用它来劫持令牌。

在本练习中，我们假设攻击者已经入侵了域 `dev.bistro.thm：8002`，并且可以在服务器上托管任何 HTML 页面。

这个是我们伪造的重定向的网页
![image.png](https://s2.loli.net/2025/09/16/Jbr6Bv2cK8UCnXl.png)

点击 loginout，会有个认证。但前提是我们先得登录 victim 用户

![image.png](https://s2.loli.net/2025/09/16/fHaOpCYEqZyFtSc.png)

会出现受害者的 code

![image.png](https://s2.loli.net/2025/09/16/eO3odX6vZ18MGRS.png)

从攻击者的计算机上，他们可以利用拦截的授权代码调用 `/callback` 端点并将其交换为有效的访问令牌。要获取访问令牌，请访问 URL [http://bistro.thm:8000/oauthdemo/callbackforflag/?code=xxxxx](http://bistro.thm:8000/oauthdemo/callbackforflag/?code=xxxx) 并将 `code` 参数替换为获取的授权代码

![image.png](https://s2.loli.net/2025/09/16/ueS6Z28dxOyRf9i.png)

## task 7 Exploiting OAuth - CSRF in OAuth  利用 OAuth - OAuth 中的 CSRF
OAuth 2.0 框架中的 **state** 参数可防止 CSRF 攻击，当攻击者诱骗用户在当前经过身份验证的 Web 应用程序上执行不需要的作时，就会发生 CSRF 攻击。在 OAuth 的上下文中，CSRF 攻击可能会劫持 OAuth 流，从而导致对敏感资源的未经授权的访问。state 参数通过维护授权过程的完整性来帮助降低此风险。

state 参数是客户端应用程序包含在授权请求中的任意字符串。当授权服务器使用授权代码将用户重定向回客户端应用程序时，它还包括 state 参数。然后，客户端应用程序验证响应中的状态参数是否与它最初发送的参数匹配。此验证可确保响应不是 CSRF 攻击的结果，而是 OAuth 流的合法延续。

例如，考虑一个 OAuth 实现，其中状态参数**缺失**或**可预测** （例如，像“state”这样的静态值或简单的序列号）。攻击者可以启动 OAuth 流并提供其恶意重定向 URI。在用户对应用程序进行身份验证和授权后，授权服务器将授权代码重定向到攻击者控制的 URI，如弱或缺席状态参数所指定。

练习中是缺乏 state 参数的情况

![image.png](https://s2.loli.net/2025/09/16/93Bl8PJCWzbiE4n.png)

首先先登录

![image.png](https://s2.loli.net/2025/09/16/lAeSRr6iQCZxw1p.png)

点击蓝色按钮就会被重定向到登录界面

![image.png](https://s2.loli.net/2025/09/16/mgjaLpAPNOoVlRJ.png)

用 thm 提供的账号密码来登录
![image.png](https://s2.loli.net/2025/09/16/4JTpHB3iqn7YZtI.png)

用给出的 payload 进行登录 victim 用户

![image.png](https://s2.loli.net/2025/09/16/J6pqHxPOhjdzAQg.png)

得到 flag
![image.png](https://s2.loli.net/2025/09/16/BK6EHeNMg24roAm.png)

##  Exploiting OAuth - Implicit Grant Flow  利用 OAuth - 隐式授权流
在隐式授权流中，令牌通过浏览器直接返回给客户端，无需中间授权代码。此流主要由单页应用程序使用，专为无法安全存储客户端密钥的公共客户端而设计。但是，此流具有固有的漏洞：

Weaknesses  弱点

- 在 **URL 中公开访问令牌** ：  应用程序将用户重定向到 OAuth 授权端点，该端点返回 URL 片段中的访问令牌。页面上运行的任何脚本都可以轻松访问此片段。
- **重定向 URI 验证不充分** ： OAuth 服务器未充分验证重定向 URI，从而允许潜在攻击者纵重定向端点。
- **无 HTTPS 实现** ：应用程序不强制执行 HTTPS，这可能导致中间人攻击拦截令牌。
- **访问令牌处理不当** ：  应用程序将访问令牌存储不安全，可能存储在 `localStorage` 或 `sessionStorage` 中，使其容易受到 XSS 攻击。


于存在这些漏洞，[OAuth 2.0 安全当前最佳实践](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)  建议弃用隐式授权流，转而使用代码[交换证明密钥](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) （PKCE） 的授权代码流。此更新的流程通过降低令牌暴露和缺乏客户端身份验证的风险来增强安全性。

## 总结
![image.png](https://s2.loli.net/2025/09/16/ZpCdfEtIJyzDm4u.png)

也是搞完这个了，这个有点小复杂。csrf 等 web 漏洞